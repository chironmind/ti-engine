"use strict";(self.webpackChunkti_engine_docs=self.webpackChunkti_engine_docs||[]).push([[122],{3475:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"tutorials/websockets","title":"Tutorial: Hybrid REST + WebSocket indicators \u2014 bulk & single calculations with ti-engine","description":"In this tutorial, you\u2019ll build a live dashboard that combines:","source":"@site/docs/tutorials/websockets.md","sourceDirName":"tutorials","slug":"/tutorials/websockets","permalink":"/ti-engine/docs/tutorials/websockets","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Tutorial 4: Connecting to a Market Data API (JavaScript)","permalink":"/ti-engine/docs/tutorials/api"}}');var s=i(4848),t=i(8453);const o={},r="Tutorial: Hybrid REST + WebSocket indicators \u2014 bulk & single calculations with ti-engine",a={},c=[{value:"\ud83c\udfaf What you\u2019ll learn",id:"-what-youll-learn",level:2},{value:"\ud83d\udce6 Prerequisites",id:"-prerequisites",level:2},{value:"\ud83e\uddf1 Project scaffold",id:"-project-scaffold",level:2},{value:"1\ufe0f\u20e3 Fetch historical data via REST",id:"1\ufe0f\u20e3-fetch-historical-data-via-rest",level:2},{value:"2\ufe0f\u20e3 Run bulk calculations on historical data",id:"2\ufe0f\u20e3-run-bulk-calculations-on-historical-data",level:2},{value:"3\ufe0f\u20e3 Initialize the live Plotly dashboard",id:"3\ufe0f\u20e3-initialize-the-live-plotly-dashboard",level:2},{value:"4\ufe0f\u20e3 Subscribe to live bars via WebSocket",id:"4\ufe0f\u20e3-subscribe-to-live-bars-via-websocket",level:2},{value:"\ud83e\udde0 Interpretation",id:"-interpretation",level:2},{value:"\ud83d\udee1\ufe0f Disclaimer",id:"\ufe0f-disclaimer",level:2}];function d(n){const e={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"tutorial-hybrid-rest--websocket-indicators--bulk--single-calculations-with-ti-engine",children:"Tutorial: Hybrid REST + WebSocket indicators \u2014 bulk & single calculations with ti-engine"})}),"\n",(0,s.jsx)(e.p,{children:"In this tutorial, you\u2019ll build a live dashboard that combines:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bulk"})," calculations (for historical data, batch analysis)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Single"})," calculations (for real-time updates, streaming)"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["You\u2019ll fetch historical OHLCV bars from Binance REST API, run full-series indicator calculations, then subscribe to new bars via Binance WebSocket and compute indicators for each new tick.",(0,s.jsx)(e.br,{}),"\n","All charted live in Plotly.js!"]}),"\n",(0,s.jsx)(e.p,{children:"This tutorial is the last in the series:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"/ti-engine/docs/tutorials/getting-started",children:"01 - Getting started with ti-engine"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"/ti-engine/docs/tutorials/plotting",children:"02 - Visualizing Indicators with Plotly"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"/ti-engine/docs/tutorials/advanced",children:"03 - More advanced use cases"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"/ti-engine/docs/tutorials/api",children:"04 - Getting data from an API"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"/ti-engine/docs/tutorials/websockets",children:"05 - Real-time updates with WebSockets (single vs bulk)"})}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"-what-youll-learn",children:"\ud83c\udfaf What you\u2019ll learn"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"How to fetch historical 1m bars from Binance via REST"}),"\n",(0,s.jsx)(e.li,{children:"How to run \u201cbulk\u201d indicator calculations with ti-engine"}),"\n",(0,s.jsx)(e.li,{children:"How to subscribe to live 1m bars via Binance WebSocket"}),"\n",(0,s.jsx)(e.li,{children:"How to run \u201csingle\u201d indicator calculations on new bars"}),"\n",(0,s.jsx)(e.li,{children:"How to display a live technical dashboard with Plotly.js"}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"-prerequisites",children:"\ud83d\udce6 Prerequisites"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Modern browser (recommended for this tutorial)"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"ti-engine"})," (technical indicators)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"plotly.js-dist-min"})," (for charting)"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"npm install ti-engine plotly.js-dist-min\n"})}),"\n",(0,s.jsxs)(e.p,{children:["If you prefer using Plotly via CDN, you can include ",(0,s.jsx)(e.code,{children:'<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"><\/script>'})," in your HTML."]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"-project-scaffold",children:"\ud83e\uddf1 Project scaffold"}),"\n",(0,s.jsx)(e.p,{children:"Minimal HTML to host the dashboard:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",children:'<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <title>Hybrid REST + WebSocket Technical Dashboard</title>\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"><\/script>\n  </head>\n  <body>\n    <div id="chart" style="width: 100%; max-width: 1200px; margin: 0 auto; height: 700px;"></div>\n    <pre id="log" style="max-width: 1000px; margin: 1rem auto; white-space: pre-wrap;"></pre>\n    <script type="module" src="/hybrid-dashboard.mjs"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"1\ufe0f\u20e3-fetch-historical-data-via-rest",children:"1\ufe0f\u20e3 Fetch historical data via REST"}),"\n",(0,s.jsx)(e.p,{children:"Use Binance\u2019s REST API to get the last N 1m bars for your symbol."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'// hybrid-dashboard.mjs\nimport init, {\n  movingAverage,\n  momentumIndicators,\n  candleIndicators,\n  otherIndicators,\n  ConstantModelType,\n  DeviationModel,\n  MovingAverageType\n} from "ti-engine";\n\nawait init();\n\nconst SYMBOL = "BTCUSDT";\nconst INTERVAL = "1m";\nconst REST_LIMIT = 500; // Binance max is 1000 for most intervals\n\nasync function fetchBinanceKlines(symbol = "BTCUSDT", interval = "1m", limit = 500) {\n  const url = new URL("https://api.binance.com/api/v3/klines");\n  url.searchParams.set("symbol", symbol);\n  url.searchParams.set("interval", interval);\n  url.searchParams.set("limit", String(limit));\n  const resp = await fetch(url);\n  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);\n  const raw = await resp.json();\n  // [OpenTime, Open, High, Low, Close, Volume, ...]\n  const date = [], open = [], high = [], low = [], close = [], volume = [];\n  for (const row of raw) {\n    date.push(new Date(row[0]).toISOString());\n    open.push(+row[1]);\n    high.push(+row[2]);\n    low.push(+row[3]);\n    close.push(+row[4]);\n    volume.push(+row[5]);\n  }\n  return { date, open, high, low, close, volume };\n}\n\nconst history = await fetchBinanceKlines(SYMBOL, INTERVAL, REST_LIMIT);\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"2\ufe0f\u20e3-run-bulk-calculations-on-historical-data",children:"2\ufe0f\u20e3 Run bulk calculations on historical data"}),"\n",(0,s.jsx)(e.p,{children:"Pick your indicator periods:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"const SMA_PERIOD = 20;\nconst BANDS_PERIOD = 20;\nconst BANDS_MODEL = ConstantModelType.ExponentialMovingAverage;\nconst DEV_MODEL = DeviationModel.StandardDeviation;\nconst DEV_MULT = 2.0;\nconst RSI_PERIOD = 14;\nconst RSI_MODEL = ConstantModelType.SmoothedMovingAverage;\nconst ATR_PERIOD = 14;\nconst ATR_MODEL = ConstantModelType.ExponentialMovingAverage;\n"})}),"\n",(0,s.jsx)(e.p,{children:"Perform bulk calculations (for the whole historical series):"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"const smaBulk = movingAverage.bulk.movingAverage(\n  history.close, MovingAverageType.Simple, SMA_PERIOD\n);\n\nconst bandsBulk = candleIndicators.bulk.movingConstantBands(\n  history.close, BANDS_MODEL, DEV_MODEL, DEV_MULT, BANDS_PERIOD\n);\nconst mcbLowerBulk = bandsBulk.map(b => b[0]);\nconst mcbMidBulk   = bandsBulk.map(b => b[1]);\nconst mcbUpperBulk = bandsBulk.map(b => b[2]);\n\nconst rsiBulk = momentumIndicators.bulk.relativeStrengthIndex(\n  history.close, RSI_MODEL, RSI_PERIOD\n);\n\nconst atrBulk = otherIndicators.bulk.averageTrueRange(\n  history.close, history.high, history.low, ATR_MODEL, ATR_PERIOD\n);\n\n// For x-axis alignment, right-align rolling outputs to their corresponding dates\nconst tail = (xs, n) => xs.slice(xs.length - n);\nconst xSMA   = tail(history.date, smaBulk.length);\nconst xBands = tail(history.date, bandsBulk.length);\nconst xRSI   = tail(history.date, rsiBulk.length);\nconst xATR   = tail(history.date, atrBulk.length);\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"3\ufe0f\u20e3-initialize-the-live-plotly-dashboard",children:"3\ufe0f\u20e3 Initialize the live Plotly dashboard"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'const chartDiv = document.getElementById("chart");\n\nconst traces = [\n  // Candles\n  {\n    type: "candlestick",\n    x: history.date,\n    open: history.open,\n    high: history.high,\n    low: history.low,\n    close: history.close,\n    name: "Price",\n    xaxis: "x",\n    yaxis: "y"\n  },\n  // SMA (bulk)\n  {\n    type: "scatter",\n    mode: "lines",\n    x: xSMA,\n    y: smaBulk,\n    name: `SMA ${SMA_PERIOD} (bulk)`,\n    line: { color: "orange", width: 1.3 },\n    xaxis: "x",\n    yaxis: "y"\n  },\n  // Bands upper/lower/mid (bulk)\n  {\n    type: "scatter",\n    mode: "lines",\n    x: xBands,\n    y: mcbUpperBulk,\n    name: "MCB Upper (bulk)",\n    line: { color: "royalblue", width: 1 },\n    opacity: 0.7,\n    xaxis: "x",\n    yaxis: "y"\n  },\n  {\n    type: "scatter",\n    mode: "lines",\n    x: xBands,\n    y: mcbLowerBulk,\n    name: "MCB Lower (bulk)",\n    line: { color: "royalblue", width: 1 },\n    fill: "tonexty",\n    fillcolor: "rgba(65,105,225,0.15)",\n    opacity: 0.7,\n    xaxis: "x",\n    yaxis: "y"\n  },\n  {\n    type: "scatter",\n    mode: "lines",\n    x: xBands,\n    y: mcbMidBulk,\n    name: "MCB Mid (bulk)",\n    line: { color: "royalblue", width: 0.8, dash: "dot" },\n    opacity: 0.6,\n    xaxis: "x",\n    yaxis: "y"\n  },\n  // RSI panel\n  {\n    type: "scatter",\n    mode: "lines",\n    x: xRSI,\n    y: rsiBulk,\n    name: `RSI ${RSI_PERIOD} (bulk)`,\n    line: { color: "purple" },\n    xaxis: "x2",\n    yaxis: "y2"\n  },\n  // ATR panel\n  {\n    type: "bar",\n    x: xATR,\n    y: atrBulk,\n    name: `ATR ${ATR_PERIOD} (bulk)`,\n    marker: { color: "gray" },\n    opacity: 0.7,\n    xaxis: "x3",\n    yaxis: "y3"\n  }\n];\n\nconst layout = {\n  title: "Hybrid REST + WebSocket Technical Dashboard",\n  template: "plotly_white",\n  hovermode: "x unified",\n  grid: { rows: 3, columns: 1, pattern: "independent" },\n  yaxis:  { domain: [0.45, 1.0], title: "Price" },\n  yaxis2: { domain: [0.22, 0.42], title: "RSI", range: [0, 100] },\n  yaxis3: { domain: [0.00, 0.20], title: "ATR" },\n  xaxis_rangeslider_visible: false,\n  shapes: [\n    { type: "line", xref: "x2", yref: "y2", x0: xRSI[0], x1: xRSI[xRSI.length-1], y0: 70, y1: 70, line: { dash: "dash", color: "red" } },\n    { type: "line", xref: "x2", yref: "y2", x0: xRSI[0], x1: xRSI[xRSI.length-1], y0: 30, y1: 30, line: { dash: "dash", color: "green" } }\n  ]\n};\n\nconst config = { responsive: true, displaylogo: false };\n\nPlotly.newPlot(chartDiv, traces, layout, config);\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"4\ufe0f\u20e3-subscribe-to-live-bars-via-websocket",children:"4\ufe0f\u20e3 Subscribe to live bars via WebSocket"}),"\n",(0,s.jsxs)(e.p,{children:["On each closed bar, append to your arrays, run ",(0,s.jsx)(e.strong,{children:"single"})," indicator calculations, and update the dashboard."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'const WS_URL = `wss://stream.binance.com:9443/ws/${SYMBOL.toLowerCase()}@kline_${INTERVAL}`;\n\nconst MAX_BARS = 1000; // Cap buffer size\n\n// Mutable arrays for appending live bars\nconst rolling = {\n  date: history.date.slice(),\n  open: history.open.slice(),\n  high: history.high.slice(),\n  low:  history.low.slice(),\n  close:history.close.slice()\n};\n\nfunction pushBar(d, o, h, l, c) {\n  rolling.date.push(d);\n  rolling.open.push(o);\n  rolling.high.push(h);\n  rolling.low.push(l);\n  rolling.close.push(c);\n\n  // Cap buffer size\n  Object.keys(rolling).forEach(k => {\n    if (rolling[k].length > MAX_BARS) rolling[k].shift();\n  });\n}\n\nfunction computeSingles() {\n  const L = rolling.close.length;\n  return {\n    sma:    L >= SMA_PERIOD   ? movingAverage.single.movingAverage(rolling.close.slice(-SMA_PERIOD), MovingAverageType.Simple) : undefined,\n    bands:  L >= BANDS_PERIOD ? candleIndicators.single.movingConstantBands(rolling.close.slice(-BANDS_PERIOD), BANDS_MODEL, DEV_MODEL, DEV_MULT) : undefined,\n    rsi:    L >= RSI_PERIOD   ? momentumIndicators.single.relativeStrengthIndex(rolling.close.slice(-RSI_PERIOD), RSI_MODEL) : undefined,\n    atr:    L >= ATR_PERIOD   ? otherIndicators.single.averageTrueRange(\n              rolling.close.slice(-ATR_PERIOD),\n              rolling.high.slice(-ATR_PERIOD),\n              rolling.low.slice(-ATR_PERIOD),\n              ATR_MODEL\n            ) : undefined\n  };\n}\n\nfunction updateChart(d, o, h, l, c, singles) {\n  // Extend price and overlay traces\n  Plotly.extendTraces(chartDiv,\n    {\n      x:    [[d], [d], [d], [d], [d], [d], [d]],\n      open: [[o], null, null, null, null, null, null],\n      high: [[h], null, null, null, null, null, null],\n      low:  [[l], null, null, null, null, null, null],\n      close:[[c], null, null, null, null, null, null],\n      y:    [null, [singles.sma ?? null], [singles.bands?.[2] ?? null], [singles.bands?.[0] ?? null], [singles.bands?.[1] ?? null], [singles.rsi ?? null], [singles.atr ?? null]]\n    },\n    [0,1,2,3,4,5,6],\n    MAX_BARS\n  );\n}\n\nconst logEl = document.getElementById("log");\nconst log = (...args) => {\n  if (logEl) logEl.textContent = `${args.map(String).join(" ")}\\n${logEl.textContent}`.slice(0, 20000);\n};\n\nfunction connectWebSocket() {\n  const ws = new WebSocket(WS_URL);\n  ws.onopen = () => log(`WebSocket connected: ${WS_URL}`);\n  ws.onmessage = (ev) => {\n    try {\n      const msg = JSON.parse(ev.data);\n      const k = msg.k;\n      if (k && k.x === true) {\n        const d = new Date(k.T).toISOString();\n        const o = +k.o, h = +k.h, l = +k.l, c = +k.c;\n\n        pushBar(d, o, h, l, c);\n\n        const singles = computeSingles();\n\n        log(\n          `[${d}]`, `Close=${c}`,\n          singles.sma !== undefined ? `SMA=${singles.sma.toFixed(2)}` : "",\n          singles.bands ? `MCB L=${singles.bands[0].toFixed(2)} M=${singles.bands[1].toFixed(2)} U=${singles.bands[2].toFixed(2)}` : "",\n          singles.rsi !== undefined ? `RSI=${singles.rsi.toFixed(2)}` : "",\n          singles.atr !== undefined ? `ATR=${singles.atr.toFixed(2)}` : ""\n        );\n\n        updateChart(d, o, h, l, c, singles);\n      }\n    } catch (e) {\n      log("Parse error:", e);\n    }\n  };\n  ws.onclose = () => {\n    log("WebSocket closed, reconnecting in 5s...");\n    setTimeout(connectWebSocket, 5000);\n  };\n  ws.onerror = (err) => {\n    log("WebSocket error:", err);\n    ws.close();\n  };\n}\n\nconnectWebSocket();\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"-interpretation",children:"\ud83e\udde0 Interpretation"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bulk"})," calculations: run once on history, produce full-series overlays (SMA, Bands, RSI, ATR)."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Single"})," calculations: run per new bar, produce latest overlays/indicators for real-time display."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plotly"})," displays both historical and live overlays, updating traces as new bars stream in."]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"\ufe0f-disclaimer",children:"\ud83d\udee1\ufe0f Disclaimer"}),"\n",(0,s.jsxs)(e.p,{children:["This is an educational example; for production, add robust error handling, rate limiting, and security.",(0,s.jsx)(e.br,{}),"\n","Always observe Binance\u2019s API terms of use."]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.p,{children:"Happy charting and streaming! \ud83d\udcc8\ud83e\udd80"})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>r});var l=i(6540);const s={},t=l.createContext(s);function o(n){const e=l.useContext(t);return l.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),l.createElement(t.Provider,{value:e},n.children)}}}]);